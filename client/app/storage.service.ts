import { Beneficiary, Payment } from 'rightfoot-node/1-3/api';
import { BehaviorSubject, combineLatest, Observable } from 'rxjs';
import { Injectable } from '@angular/core';
import { DemoProgress } from './demo-progress';
import { map } from 'rxjs/operators';

/**
 * This static service is used to store required data for requests.
 * It roughly emulates this application's API backend server where useful data about
 * objects we create through Rightfoot Public API is stored.
 */
@Injectable({
  providedIn: 'root',
})
export class StorageService {
  private static readonly BENEFICIARY_ID_KEY = 'b_uuid';
  private static readonly PAYMENTS_ENABLED_KEY = 'p_e';
  private static readonly PAYMENT_UUID_KEY = 'p_u';
  private static readonly PAYMENT_RESPONSE = 'p_resp';

  private static readonly storage = window.sessionStorage;

  private beneficiaryIdSubject = new BehaviorSubject<string | null>(
      StorageService.storage.getItem(StorageService.BENEFICIARY_ID_KEY));

  /**
   * Returns cached beneficiary id.
   */
  public beneficiaryId$: Observable<string> =
      this.beneficiaryIdSubject.asObservable();

  private paymentsEnabledSubject = new BehaviorSubject<boolean | null>(
    (() => {
      const value = StorageService.storage.getItem(
        StorageService.PAYMENTS_ENABLED_KEY);
      return value ? JSON.parse(value) : null;
    })()
  );

  /**
   * Returns cached paymentsEnabled value
   * which indicates if payments are enabled for this user.
   */
  public paymentsEnabled$: Observable<boolean | null> =
      this.paymentsEnabledSubject.asObservable();

  private paymentIdSubject = new BehaviorSubject<string | null>(
      StorageService.storage.getItem(StorageService.PAYMENT_UUID_KEY));

  /**
   * Returns stream with a currently stored payment uuid.
   */
  public paymentId$: Observable<string | null> =
      this.paymentIdSubject.asObservable();

  private paymentStatusResponseSubject = new BehaviorSubject<Payment | null>(
      JSON.parse(StorageService.storage.getItem(StorageService.PAYMENT_RESPONSE)));

  /**
   * Returns stored Payment status response.
   */
  public paymentStatusResponse$: Observable<Payment> =
    this.paymentStatusResponseSubject.asObservable();

  /**
   * Returns stream with a currently stored current step.
   */
  public currentStep$: Observable<DemoProgress> = combineLatest([
    this.beneficiaryId$,
    this.paymentsEnabled$,
    this.paymentId$,
  ]).pipe(
    map(([beneficiaryId, paymentsEnabled, paymentId]) => {
      if (!beneficiaryId) {
        return DemoProgress.CREATE_BENEFICIARY;
      }

      if (!paymentsEnabled) {
        return DemoProgress.LINK_LOAN;
      }

      if (!paymentId) {
        return DemoProgress.CREATE_PAYMENT;
      }

      return DemoProgress.CHECK_PAYMENT;
    })
  );

  /**
   * Caches beneficiary's id in the session storage.
   * @param beneficiary user to store id for.
   */
  public storeBeneficiaryId(beneficiary: Beneficiary): void {
    StorageService.storage.setItem(
        StorageService.BENEFICIARY_ID_KEY,
        beneficiary.uuid);
    this.beneficiaryIdSubject.next(beneficiary.uuid);
  }

  /**
   * Caches value which indicates if payments are enabled for this user.
   */
  public storePaymentsEnabled(paymentsEnabled: boolean): void {
    this.paymentsEnabledSubject.next(paymentsEnabled);
    StorageService.storage.setItem(
      StorageService.PAYMENTS_ENABLED_KEY,
      JSON.stringify(paymentsEnabled)
    );
  }

  /**
   * Caches created payment's UUID.
   * @param uuid Unique identifier generated by Rightfoot.
   */
  public storePaymentId(uuid: string): void {
    this.paymentIdSubject.next(uuid);
    StorageService.storage.setItem(StorageService.PAYMENT_UUID_KEY, uuid);
  }

  /**
   * Store full Rightfoot payment creation response.
   */
  public storePaymentResponse(response: Payment): void {
    this.paymentStatusResponseSubject.next(response);
    StorageService.storage.setItem(
      StorageService.PAYMENT_RESPONSE,
      JSON.stringify(response));
  }

  /**
   * Resets application state.
   */
  public clearAll(): void {
    StorageService.storage.clear();
  }
}
